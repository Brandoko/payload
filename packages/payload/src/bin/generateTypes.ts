import fs from 'fs'
import { compile } from 'json-schema-to-typescript'

import type { SanitizedConfig } from '../config/types.js'

import { configToJSONSchema } from '../utilities/configToJSONSchema.js'
import { getLogger } from '../utilities/logger.js'

type TransformFunction = (input: string) => {
  generics?: string[]
  specifier: string
}

interface ProcessResult {
  processedContent: string
}

function processExternalImports(
  fileContent: string,
  transformFunction: TransformFunction,
): ProcessResult {
  const regex = /'externalImport:([^']+)'/g

  const processedContent = fileContent.replace(regex, (match: string, captureGroup: string) => {
    const { generics, specifier } = transformFunction(captureGroup)
    if (generics && generics.length > 0) {
      return specifier + '<' + generics.join(',') + '>'
    }
    return specifier
  })

  return {
    processedContent,
  }
}

export async function generateTypes(
  config: SanitizedConfig,
  options?: { log: boolean },
): Promise<void> {
  const logger = getLogger('payload', 'sync')
  const outputFile = process.env.PAYLOAD_TS_OUTPUT_PATH || config.typescript.outputFile

  const shouldLog = options?.log ?? true

  if (shouldLog) {
    logger.info('Compiling TS types for Collections and Globals...')
  }

  const jsonSchema = configToJSONSchema(config, config.db.defaultIDType)

  const declare = `declare module 'payload' {\n  export interface GeneratedTypes extends Config {}\n}`
  const declareWithTSIgnoreError = `declare module 'payload' {\n  // @ts-ignore \n  export interface GeneratedTypes extends Config {}\n}`

  const _compiled = await compile(jsonSchema, 'Config', {
    bannerComment:
      '/* tslint:disable */\n/* eslint-disable */\n/**\n* This file was automatically generated by Payload.\n* DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,\n* and re-run `payload generate:types` to regenerate this file.\n*/',
    style: {
      singleQuote: true,
    },
    // Generates code for $defs that aren't referenced by the schema. Reason:
    // If a field defines an interfaceName, it should be included in the generated types
    // even if it's not used by another type. Reason: the user might want to use it in their own code.
    unreachableDefinitions: true,
  })

  /*
   * Process external imports
   */
  let importsFound = 0
  const importStrings: string[] = []
  const specifiers: string[] = []
  const rawImportStrings: string[] = []

  const { processedContent } = processExternalImports(_compiled, (captureGroup) => {
    const importString = captureGroup.split(':')[0]
    let generics: string[] = []
    if (captureGroup.includes(':')) {
      // Defines generics
      generics = captureGroup.split(':')[1].split(',')
    }

    const importStringSplit = importString.split('#')

    const importPath = importStringSplit[0]
    const specifier = importStringSplit[1]

    if (rawImportStrings.includes(importString)) {
      const safeSpecifier = specifier + '_' + importsFound
      return {
        generics,
        specifier: safeSpecifier,
      }
    }
    importsFound++
    rawImportStrings.push(importString)
    const safeSpecifier = specifier + '_' + importsFound
    const fullImportString = `import { ${specifier} as ${safeSpecifier} } from '${importPath}'`
    specifiers.push(safeSpecifier)

    importStrings.push(fullImportString)
    return {
      generics,
      specifier: safeSpecifier,
    }
  })

  /*
   * Done processing external imports
   */

  let compiled = processedContent
  compiled = importStrings.join('\n') + '\n\n' + compiled

  if (config.typescript.declare !== false) {
    if (config.typescript.declare?.ignoreTSError) {
      compiled += `\n\n${declareWithTSIgnoreError}`
    } else {
      compiled += `\n\n${declare}`
    }
  }

  // Diff the compiled types against the existing types file
  try {
    const existingTypes = fs.readFileSync(outputFile, 'utf-8')

    if (compiled === existingTypes) {
      return
    }
  } catch (_) {
    // swallow err
  }

  fs.writeFileSync(outputFile, compiled)
  if (shouldLog) {
    logger.info(`Types written to ${outputFile}`)
  }
}
